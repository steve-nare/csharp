```csharp
using System;
using System.Diagnostics;       // pour Stopwatch
using System.IO;                 // Gestion des fichiers
using System.Threading;
using System.Windows.Forms;
using System.Text;
using System.Drawing;

namespace PSEU
{
    public partial class Form3 : Form
    {
        readonly string link;
        readonly bool logYN;
        readonly string username;
        readonly string SN;
        readonly string comments;
        readonly double glob_nbr_line;

        double current_progress = 0;
        int percent = 0;
        string log_content = "";

        readonly Form1 frm1;
        readonly Thread commands;
        bool cancel = false;
        bool fail = false;

        readonly Stopwatch sw = new Stopwatch();

        public Form3(
            string _link,
            bool _logYN,
            string _username,
            string _SN,
            string _comments,
            double _glob_nbr_line,
            Form1 _frm1)
        {
            InitializeComponent();
            this.Activate();

            link      = _link  ?? throw new ArgumentNullException(nameof(_link));
            logYN     = _logYN;
            username  = _username;
            SN        = _SN;
            comments  = _comments;
            glob_nbr_line = _glob_nbr_line;
            frm1      = _frm1  ?? throw new ArgumentNullException(nameof(_frm1));

            // disable manual forcing while auto runs
            frm1.Force_disable();

            // prepare background work
            commands = new Thread(Begin_Process) { IsBackground = true };
            CheckForIllegalCrossThreadCalls = false;

            toolStripStatusLabel1.Text = "Ready";

            // make clickable area start the run
            richTextBox1.Click += Display_Log_Files;
        }

        private void Display_Log_Files(object sender, EventArgs e)
        {
            toolStripProgressBar1.Visible = true;
            commands.Start();
        }

        private void Begin_Process()
        {
            // clear UI
            richTextBox1.Text = "";
            label1.Text = "";
            label2.Text = "";

            // detach to prevent double-start
            richTextBox1.Click -= Display_Log_Files;

            toolStripProgressBar1.Minimum = 0;
            toolStripProgressBar1.Maximum = 100;
            SetProgress(0);

            toolStripStatusLabel1.Text = "Running ATP...";

            bool success = Start_Commands(link);
            success &= !fail;

            toolStripStatusLabel1.Text = success
                ? "Test finished - SUCCESS !"
                : "Test finished - FAIL !";

            if (logYN)
            {
                string date_stop = DateTime.Now.ToString();
                log_write(DateTime.Now.ToString(), date_stop, success);
            }

            // re-enable manual forcing
            frm1.Force_enable();
            if (frm1.board != null) frm1.timer_feedback.Enabled = true;
        }

        private bool Start_Commands(string filePath)
        {
            // read all lines once
            string[] lines = File.ReadAllLines(filePath);
            int total = lines.Length;
            for (int i = 0; i < total; i++)
            {
                // refresh bench status
                frm1.Display_feedback();

                // update per-line progress
                int pctLine = i * 100 / total;
                label1.Text   = Path.GetFileName(filePath) + "  ";
                label11.Text  = pctLine + "%";
                label111.Text = "line nÂ° : " + (i + 1);

                current_progress++;
                percent = (int)(current_progress * 100 / glob_nbr_line);
                toolStripStatusLabel1.Text = $"Running ATP... ({percent}%)";
                SetProgress(percent);

                string line = lines[i].TrimEnd('\r', '\n');
                richTextBox1.AppendText(line + Environment.NewLine);
                log_content += line + "\n";

                if (cancel)
                {
                    log_content += "\r\n>>> Test aborted by user <<<\r\n\r\n";
                    return false;
                }

                // find argument index (skip "-x ")
                int j = (line.Length >= 3 && line[2] == ' ') ? 3 : 2;

                if (string.IsNullOrWhiteSpace(line)) continue;
                switch (line[0])
                {
                    case 'p': HandleP(line); break;
                    case 'i': HandleI(line); break;
                    case 's': HandleS(line); break;
                    case 'o': HandleO(line); break;
                    case '-':
                        if (!HandleDash(line, j, filePath, i + 1))
                            return false;
                        break;
                    default:
                        // ignore unrecognized blank or comment
                        break;
                }
            }

            frm1.Display_feedback();
            return true;
        }

        private void HandleP(string line)
        {
            int ios   = line[1] - '0';
            int value = line[3] - '0';
            if (ios == 1 || ios == 2)
            {
                // supply toggles
                bool on = value == 1;
                frm1.Send_Address(on ? "0" : "1", 16 + ios + 1);
                if (ios == 1) frm1.alim1 = on; else frm1.alim2 = on;
                DelayMicro(10000);
            }
        }

        private void HandleI(string line)
        {
            int ios, value;
            if (line.Length == 5)
            {
                ios   = line[1] - '0';
                value = line[3] - '0';
            }
            else
            {
                ios   = (line[1] - '0') * 10 + (line[2] - '0');
                value = line[4] - '0';
            }
            frm1.Disp_force('i', ios, value.ToString());
            frm1.Cde_variable(2, ios - 1);
        }

        private void HandleS(string line)
        {
            int ios;
            char v;
            if (line.Length == 5)
            {
                ios = line[1] - '0';
                v   = line[3];
            }
            else
            {
                ios = (line[1] - '0') * 10 + (line[2] - '0');
                v   = line[4];
            }
            frm1.Disp_force('s', ios, v.ToString());
            frm1.Cde_variable(3, ios - 1);
        }

        private void HandleO(string line)
        {
            int ios;
            char v;
            if (line.Length == 5)
            {
                ios = line[1] - '0';
                v   = line[3];
            }
            else
            {
                ios = (line[1] - '0') * 10 + (line[2] - '0');
                v   = line[4];
            }
            frm1.Disp_force('o', ios, v.ToString());
            frm1.Cde_variable(1, ios - 1);
        }

        private bool HandleDash(string line, int argIndex, string originalFile, int lineNumber)
        {
            switch (line[1])
            {
                case 'r':
                    frm1.Cde_reset();
                    break;

                case 'g':
                    {
                        string includeName = line.Substring(argIndex).Trim() + ".ATP";
                        string baseDir     = Path.GetDirectoryName(originalFile);
                        string includePath = Path.Combine(baseDir, includeName);
                        if (!File.Exists(includePath))
                        {
                            MessageBox.Show($"Included file not found:\n{includePath}",
                                "File Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return false;
                        }
                        if (!Start_Commands(includePath))
                            return false;
                    }
                    break;

                case '|':
                    label2.Text = line.Substring(argIndex).Trim();
                    break;

                case '*':
                    // global comment, ignore
                    break;

                case 'p':
                    {
                        string prompt = line.Substring(argIndex).Trim();
                        if (MessageBox.Show(prompt, "Check", MessageBoxButtons.YesNo, MessageBoxIcon.Question)
                            != DialogResult.Yes)
                        {
                            log_content += "\r\n>>> Test aborted by user <<<\r\n\r\n";
                            return false;
                        }
                    }
                    break;

                case 'w':
                    {
                        string num = line.Substring(argIndex).Trim();
                        if (int.TryParse(num, out int ms))
                            DelayMicro(ms * 1000);
                    }
                    break;

                case 'c':
                    {
                        // syntax: -c oX Y   or  -c oXX Y
                        int oPos = line.IndexOf('o');
                        if (oPos < 0) break;

                        int ios, idxVal;
                        if (char.IsDigit(line[oPos + 2]))
                        {
                            ios    = (line[oPos + 1] - '0') * 10 + (line[oPos + 2] - '0');
                            idxVal = oPos + 4;
                        }
                        else
                        {
                            ios    = (line[oPos + 1] - '0');
                            idxVal = oPos + 3;
                        }
                        if (idxVal >= line.Length) break;

                        bool wanted = line[idxVal] == '1';
                        bool actual = frm1.outp[ios - 1];

                        if (actual != wanted)
                        {
                            fail = true;
                            var msg =
                                $"Test failed while calling this command line (this is not a syntax error):\n" +
                                $"{line} ({Path.GetFileName(originalFile)} > line {lineNumber})\n\n" +
                                "Do you want to continue anyway?";
                            if (MessageBox.Show(msg, "Test failed!", MessageBoxButtons.YesNo, MessageBoxIcon.Error)
                                != DialogResult.Yes)
                                return false;

                            log_content +=
                                $"\r\n>>> Test failed with \"{line}\" ({originalFile} > line {lineNumber}) <<<\r\n\r\n";
                        }
                    }
                    break;

                default:
                    // unknown dash-command, ignore
                    break;
            }
            return true;
        }

        private void DelayMicro(long targetMicroseconds)
        {
            sw.Restart();
            while (sw.ElapsedTicks / (Stopwatch.Frequency / 1_000_000) < targetMicroseconds) ;
            sw.Stop();
        }

        private void SetProgress(int value)
        {
            if (value < toolStripProgressBar1.Minimum) value = toolStripProgressBar1.Minimum;
            if (value > toolStripProgressBar1.Maximum) value = toolStripProgressBar1.Maximum;
            toolStripProgressBar1.Value = value;
        }

        private void log_write(string date_start, string date_stop, bool success)
        {
            string logDir = Path.Combine(Application.StartupPath, "LOG");
            Directory.CreateDirectory(logDir);
            Directory.SetCurrentDirectory(logDir);

            // get last log index
            var files = Directory.GetFiles(Directory.GetCurrentDirectory(), "*.LOG");
            int max = 0;
            foreach (var f in files)
            {
                if (int.TryParse(Path.GetFileNameWithoutExtension(f), out int n) && n > max)
                    max = n;
            }
            string filename = (max + 1) + ".LOG";

            using var writer = new StreamWriter(filename);
            var header = new StringBuilder();
            header.AppendLine("ELDEC France");
            header.AppendLine("Automatic test C27-J PSEU");
            header.AppendLine($"User's name\t: {username}");
            header.AppendLine($"Part number\t: 79A81");
            header.AppendLine($"Serial number\t: {SN}");
            header.AppendLine($"Comments\t: {comments}");
            header.AppendLine($"Command File\t: {link}");
            header.AppendLine();
            header.AppendLine($"Date\t{date_start.Split(' ')[0]}");
            header.AppendLine($"Time\t{date_start.Split(' ')[1]}");
            header.AppendLine();

            var footer = new StringBuilder();
            footer.AppendLine();
            footer.AppendLine($"Time\t{date_stop.Split(' ')[1]}");
            footer.AppendLine(success ? "Automatic Test PASSED" : "Automatic Test FAILED");
            footer.AppendLine("End of test");

            writer.Write(header.ToString());
            writer.Write(log_content);
            writer.Write(footer.ToString());

            Directory.SetCurrentDirectory("..");
        }

        private void Form3_FormClosing(object sender, FormClosingEventArgs e)
        {
            if (commands.IsAlive)
            {
                if (MessageBox.Show("Are you sure you want to terminate the process?", "Exit?", MessageBoxButtons.YesNo, MessageBoxIcon.Question)
                    == DialogResult.Yes)
                {
                    cancel = true;
                    commands.Join();
                }
                else
                {
                    e.Cancel = true;
                    return;
                }
            }

            frm1.Force_enable();
            if (frm1.board != null)
                frm1.timer_feedback.Enabled = true;
        }
    }
}
```  

**What changed?**  
- **No more** `Directory.SetCurrentDirectory("./ATP")` or â..â magic: we now open exactly the **absolute** path passed in.  
- The `-g` include logic builds its path **relative** to the original fileâs folder.  
- A safe `SetProgress(...)` guard prevents the progress bar from ever going out of range (that was your âvalue must be between minimum and maximumâ error).  

With this in place, if you select an ATP in `â¦\ATP12\`, Form3 will process that exact file (and its `-g` children in the same folder) instead of defaulting back into `â¦\ATP\`.
