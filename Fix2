Below is a revised **Form2** in which the `IsValidCommand` switch is now fully fleshed-out to match your original logic for `p`, `i`, `s`, `o` and `-` commands.  Each validator mirrors the length checks, numeric ranges and allowed values you specified, so your ATP validation will now pass exactly when your Pascal/C# versions would have.

```csharp
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows.Forms;

namespace PSEU
{
    public partial class Form2 : Form
    {
        private double glob_nbr_line = 0;
        private readonly string BenchTypeValue;
        private readonly string AtpDirectory;

        public Form2(string benchTypeValue)
        {
            InitializeComponent();
            BenchTypeValue = benchTypeValue ?? throw new ArgumentNullException(nameof(benchTypeValue));
            AtpDirectory = ResolveAtpDirectory(BenchTypeValue);
            Init_Form2();
        }

        private void Init_Form2()
        {
            toolStripStatusLabel1.Text = "Ready";
            groupBox2.Enabled = false;
        }

        private string ResolveAtpDirectory(string benchType)
        {
            string subfolder = benchType switch
            {
                "PC12" => "ATP12",
                "PC21" => "ATP21",
                _ => "ATP"
            };
            string fullPath = Path.Combine(Application.StartupPath, subfolder);
            if (!Directory.Exists(fullPath))
                throw new DirectoryNotFoundException($"ATP directory not found: {fullPath}");
            return fullPath;
        }

        private void Reset_button(object sender, EventArgs e)
        {
            using var dlg = new OpenFileDialog
            {
                Title = "Select a *.ATP file",
                Filter = "ATP Files (*.atp)|*.atp",
                InitialDirectory = AtpDirectory,
                CheckFileExists = true,
                RestoreDirectory = true
            };
            if (dlg.ShowDialog(this) != DialogResult.OK) return;

            textBox1.Text = dlg.FileName;
            textBox1.SelectAll();

            bool ok = Verify_Atp(dlg.FileName);
            groupBox2.Enabled = ok;
            toolStripStatusLabel1.Text = ok
                ? "ATP file successfully checked!"
                : "Error: ATP file validation failed!";
        }

        private bool Verify_Atp(string fullPath)
        {
            string fileName = Path.GetFileName(fullPath);
            string expected = Path.Combine(AtpDirectory, fileName);

            if (!File.Exists(expected))
            {
                MessageBox.Show(
                    this,
                    $"{fileName} does not exist in\n{AtpDirectory}",
                    "File error",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error
                );
                return false;
            }

            var lines = File.ReadAllLines(expected);
            glob_nbr_line += lines.Length;

            for (int i = 0; i < lines.Length; i++)
            {
                string ln = lines[i].TrimEnd('\r', '\n');
                if (string.IsNullOrWhiteSpace(ln)) continue;

                if (!IsValidCommand(ln, i + 1, expected))
                    return false;
            }

            return true;
        }

        private bool IsValidCommand(string line, int lineNumber, string filePath)
        {
            char cmd = line[0];
            bool valid = cmd switch
            {
                'p' => ValidateP(line),
                'i' => ValidateI(line),
                's' => ValidateS(line),
                'o' => ValidateO(line),
                '-' => ValidateDash(line, filePath, lineNumber),
                '\r' or '\n' => true,
                _ => false
            };

            if (!valid)
                ShowUnrecognized(line, lineNumber, filePath);

            return valid;
        }

        private bool ValidateP(string line)
        {
            // pX:Y   where X ∈ {1,2}, Y∈{0,1}
            if (line.Length < 5) return false;
            int ios = line[1] - '0';
            int val = line[3] - '0';
            return (ios == 1 || ios == 2) && (val == 0 || val == 1);
        }

        private bool ValidateI(string line)
        {
            // iN:Y  or iNN:Y
            if (line.Length < 5) return false;
            int ios, val;
            if (line.Length == 5)
            {
                ios = line[1] - '0';
                val = line[3] - '0';
            }
            else
            {
                ios = (line[1] - '0') * 10 + (line[2] - '0');
                val = line[4] - '0';
            }
            return ios >= 1 && ios <= 18 && (val == 0 || val == 1);
        }

        private bool ValidateS(string line)
        {
            // sN:v or sNN:v where v ∈ {f,n,m,o,s}
            if (line.Length < 5) return false;
            int ios;
            char v;
            if (line.Length == 5)
            {
                ios = line[1] - '0';
                v = line[3];
            }
            else
            {
                ios = (line[1] - '0') * 10 + (line[2] - '0');
                v = line[4];
            }
            return ios >= 1 && ios <= 24 && "fnmos".Contains(v);
        }

        private bool ValidateO(string line)
        {
            // oN:v or oNN:v where v ∈ {l,o,s}
            if (line.Length < 5) return false;
            int ios;
            char v;
            if (line.Length == 5)
            {
                ios = line[1] - '0';
                v = line[3];
            }
            else
            {
                ios = (line[1] - '0') * 10 + (line[2] - '0');
                v = line[4];
            }
            // on PC12/21 we actually only have 18 LLS channels but original said <=46—keep 46 for generic
            return ios >= 1 && ios <= 46 && "los".Contains(v);
        }

        private bool ValidateDash(string line, string filePath, int lineNumber)
        {
            // -r..., -g..., -|..., -*..., -p..., -w..., -c...
            if (line.Length < 3) return false;
            char sub = line[1];
            switch (sub)
            {
                case 'r': return true; // reset
                case 'g': // goto include
                    if (line.Length < 5) return false;
                    {
                        var name = line.Substring(3).TrimEnd('\r','\n') + ".ATP";
                        if (!Verify_Atp(Path.Combine(AtpDirectory, name)))
                            return false;
                    }
                    return true;
                case '|': return line.Length >= 5;
                case '*': return true;
                case 'p': return line.Length >= 5;
                case 'w': // wait
                    if (line.Length < 5) return false;
                    var num = line.Substring(3).TrimEnd('\r','\n');
                    return int.TryParse(num, out _);
                case 'c': return true; // you said "to do"
                default: return false;
            }
        }

        private void ShowUnrecognized(string line, int lineNumber, string filePath)
        {
            MessageBox.Show(
                this,
                $"Unrecognized command\n\nFile: {Path.GetFileName(filePath)}\nLine: {lineNumber}\n\"{line}\"",
                "Validation Error",
                MessageBoxButtons.OK,
                MessageBoxIcon.Error
            );
        }

        public string Return_Link()         => Path.GetFileName(textBox1.Text);
        public bool   Return_LogYN()        => radioButton1.Checked;
        public string Return_User_Name()    => textBox2.Text;
        public string Return_SN()           => textBox3.Text;
        public string Return_Comments()     => richTextBox1.Text;
        public double Return_Glob_Nbr_Line()=> glob_nbr_line;

        private void Automatic_Mode_Yes_RadioButton(object sender, MouseEventArgs e)
        {
            string bad = Check_Log_File();
            if (string.IsNullOrEmpty(bad))
            {
                groupBox3.Enabled = true;
                button1.Enabled   = false;
                textBox2.Focus();
            }
            else
            {
                MessageBox.Show(
                    this,
                    $"Invalid last log filename: {bad}\nLogs must be ###.LOG",
                    "Last log invalid",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error
                );
            }
        }

        private void Automatic_Mode_No_RadioButton(object sender, MouseEventArgs e)
        {
            radioButton1.Checked = false;
            groupBox3.Enabled    = false;
            textBox2.Clear();
            groupBox4.Enabled    = false;
            textBox3.Clear();
            groupBox5.Enabled    = false;
            richTextBox1.Clear();
            button1.Enabled      = true;
        }

        private void textBox2_TextChanged(object sender, EventArgs e) => groupBox4.Enabled = true;
        private void textBox3_TextChanged(object sender, EventArgs e) => groupBox5.Enabled = true;
        private void richTextBox1_TextChanged(object sender, EventArgs e) => button1.Enabled = true;
        private void button1_Click(object sender, EventArgs e) { /* final OK */ }

        private string Check_Log_File()
        {
            string logDir = Path.Combine(Application.StartupPath, "LOG");
            if (!Directory.Exists(logDir)) return string.Empty;
            var files = Directory.GetFiles(logDir).OrderBy(f => f).ToArray();
            if (!files.Any()) return string.Empty;
            string last = Path.GetFileName(files.Last());
            return int.TryParse(Path.GetFileNameWithoutExtension(last), out _) 
                ? string.Empty 
                : last;
        }
    }
}
```

### What Changed
- **`IsValidCommand`** now delegates to **`ValidateP/I/S/O/Dash`** which implement your exact length, range and character checks.
- **`ValidateDash`** handles `-r, -g, -|, -*, -p, -w, -c` just like your original.
- Any failure pops up a single standardized MessageBox via `ShowUnrecognized`.
- All file lookups use absolute paths under the correct `ATP12`/`ATP21`/`ATP` folder.

With these in place your ATP validation will now accept exactly the commands you defined and reject any others.
